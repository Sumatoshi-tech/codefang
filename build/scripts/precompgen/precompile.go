// Package main provides the precompilation tool for UAST mapping files.
package main

import (
	"errors"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Sumatoshi-tech/codefang/pkg/uast"
	"github.com/Sumatoshi-tech/codefang/pkg/uast/pkg/mapping"
)

// errNoUASTMapFiles is returned when no .uastmap files are found.
var errNoUASTMapFiles = errors.New("no .uastmap files found")

func main() {
	var (
		output = flag.String("o", "pkg/uast/embedded_mappings.gen.go", "output file for embedded mappings")
		quiet  = flag.Bool("q", false, "suppress output")
	)

	flag.Parse()

	logger := slog.New(slog.NewTextHandler(os.Stderr, nil))

	err := runPrecompile(logger, *output, *quiet)
	if err != nil {
		logger.Error("precompile failed", "error", err)
		os.Exit(1)
	}
}

func runPrecompile(logger *slog.Logger, outputFile string, quiet bool) error {
	uastmapsDir := "pkg/uast/uastmaps"
	if !quiet {
		logger.Info("Looking for .uastmap files", "dir", uastmapsDir)
	}

	uastmapFiles, err := findUASTMapFiles(uastmapsDir)
	if err != nil {
		return err
	}

	if !quiet {
		logger.Info("Found uastmap files to pre-compile", "count", len(uastmapFiles))
	}

	allMappings, successCount := processUASTMapFiles(logger, uastmapFiles, quiet)

	if !quiet {
		logger.Info("Pre-compilation complete", "success", successCount, "total", len(uastmapFiles))
	}

	return runPrecompileGo(logger, allMappings, outputFile, quiet)
}

func findUASTMapFiles(dir string) ([]string, error) {
	entries, readErr := os.ReadDir(dir)
	if readErr != nil {
		return nil, fmt.Errorf("failed to read uastmaps directory: %w", readErr)
	}

	var files []string

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".uastmap") {
			files = append(files, filepath.Join(dir, entry.Name()))
		}
	}

	if len(files) == 0 {
		return nil, fmt.Errorf("%w in %s/", errNoUASTMapFiles, dir)
	}

	return files, nil
}

func processUASTMapFiles(logger *slog.Logger, files []string, quiet bool) (mappings []uast.PrecompiledMapping, totalRules int) {
	var allMappings []uast.PrecompiledMapping

	successCount := 0

	for _, filePath := range files {
		precompiled, err := processUASTMapFile(logger, filePath, quiet)
		if err != nil {
			continue
		}

		allMappings = append(allMappings, precompiled)
		successCount++
	}

	return allMappings, successCount
}

func processUASTMapFile(logger *slog.Logger, filePath string, quiet bool) (uast.PrecompiledMapping, error) {
	if !quiet {
		logger.Info("Processing file", "file", filepath.Base(filePath))
	}

	uastFile, openErr := os.Open(filePath)
	if openErr != nil {
		if !quiet {
			logger.Warn("Failed to open file", "file", filepath.Base(filePath), "error", openErr)
		}

		return uast.PrecompiledMapping{}, fmt.Errorf("open UAST map file: %w", openErr)
	}

	mappingParser := &mapping.Parser{}

	rules, langInfo, parseErr := mappingParser.ParseMapping(uastFile)

	uastFile.Close()

	if parseErr != nil {
		if !quiet {
			logger.Warn("Failed to pre-compile", "file", filepath.Base(filePath), "error", parseErr)
		}

		return uast.PrecompiledMapping{}, parseErr
	}

	languageName := filepath.Base(filePath)
	languageName = strings.TrimSuffix(languageName, ".uastmap")

	return uast.PrecompiledMapping{
		Language:   languageName,
		Extensions: langInfo.Extensions,
		Rules:      rules,
		Patterns:   nil,
		CompiledAt: "",
	}, nil
}

func runPrecompileGo(logger *slog.Logger, mappings []uast.PrecompiledMapping, outputFile string, quiet bool) error {
	goCode := generateGoCode(mappings)

	mkdirErr := os.MkdirAll(filepath.Dir(outputFile), 0o750)
	if mkdirErr != nil {
		return fmt.Errorf("failed to create output directory: %w", mkdirErr)
	}

	writeErr := os.WriteFile(outputFile, []byte(goCode), 0o600)
	if writeErr != nil {
		return fmt.Errorf("failed to write Go file: %w", writeErr)
	}

	if !quiet {
		logger.Info("Go code with embedded mappings saved", "file", outputFile)
	}

	return nil
}

//nolint:funlen // This function defines a Go template which is inherently long but cannot be meaningfully split.
func generateGoCode(mappings []uast.PrecompiledMapping) string {
	const goTemplate = `// Code generated by scripts/precompile.go. DO NOT EDIT.

package uast

import (
	"fmt"
	"strings"
	"github.com/Sumatoshi-tech/codefang/pkg/uast/pkg/mapping"
)

// embeddedMappingsData contains all pre-compiled UAST mappings
var embeddedMappingsData = []PrecompiledMapping{
{{range .}}
	{
		Language: "{{.Language}}",
		Extensions: []string{
{{range .Extensions}}
			"{{.}}",
{{end}}
		},
		Rules: []mapping.Rule{
{{range .Rules}}
			{
				Name: "{{.Name}}",
				Pattern: "{{.Pattern}}",
				{{if .Extends}}Extends: "{{.Extends}}",{{end}}
				UASTSpec: mapping.UASTSpec{
					{{if .UASTSpec.Type}}Type: "{{.UASTSpec.Type}}",{{end}}
					{{if .UASTSpec.Token}}Token: "{{.UASTSpec.Token}}",{{end}}
					{{if .UASTSpec.Roles}}Roles: []string{
{{range .UASTSpec.Roles}}
						"{{.}}",
{{end}}
					},{{end}}
					{{if .UASTSpec.Children}}Children: []string{
{{range .UASTSpec.Children}}
						"{{.}}",
{{end}}
					},{{end}}
					{{if .UASTSpec.Props}}Props: map[string]string{
{{range $key, $value := .UASTSpec.Props}}
						"{{$key}}": "{{$value}}",
{{end}}
					},{{end}}
				},
				{{if .Conditions}}Conditions: []mapping.Condition{
{{range .Conditions}}
					{
						Expr: "{{.Expr}}",
					},
{{end}}
				},{{end}}
			},
{{end}}
		},
	},
{{end}}
}

// embeddedMappingsAvailable checks if embedded mappings are available
func embeddedMappingsAvailable() bool {
	return len(embeddedMappingsData) > 0
}

// loadFromEmbeddedMappingsData loads from embedded mappings data
func (l *Loader) loadFromEmbeddedMappingsData() bool {
	// Convert pre-compiled mappings to parsers
	for _, precompiledMapping := range embeddedMappingsData {
		// Create a properly initialized DSLParser
		parser := &DSLParser{
			langInfo: &mapping.LanguageInfo{
				Name:       precompiledMapping.Language,
				Extensions: precompiledMapping.Extensions,
			},
			mappingRules: precompiledMapping.Rules,
		}

		// Initialize the language field
		if err := parser.initializeLanguage(); err != nil {
			fmt.Printf("Warning: Failed to initialize language for %s: %v\n", precompiledMapping.Language, err)
			continue
		}

		l.parsers[precompiledMapping.Language] = parser
		for _, ext := range precompiledMapping.Extensions {
			l.extensions[strings.ToLower(ext)] = parser
		}
	}

	return len(embeddedMappingsData) > 0
}

// OPTIMIZATION 1: Pre-compiled pattern matchers for O(1) lookup
{{range .}}
// {{.Language}}PatternMatcher provides pre-compiled pattern matching for {{.Language}}
type {{.Language}}PatternMatcher struct {
	patterns map[string]mapping.Rule
	ruleIndex map[string]int
	rules []mapping.Rule
}

func new{{.Language}}PatternMatcher() *{{.Language}}PatternMatcher {
	rules := []mapping.Rule{
{{range .Rules}}
		{
			Name: "{{.Name}}",
			Pattern: "{{.Pattern}}",
			{{if .Extends}}Extends: "{{.Extends}}",{{end}}
			UASTSpec: mapping.UASTSpec{
				{{if .UASTSpec.Type}}Type: "{{.UASTSpec.Type}}",{{end}}
				{{if .UASTSpec.Token}}Token: "{{.UASTSpec.Token}}",{{end}}
				{{if .UASTSpec.Roles}}Roles: []string{
{{range .UASTSpec.Roles}}
					"{{.}}",
{{end}}
				},{{end}}
				{{if .UASTSpec.Children}}Children: []string{
{{range .UASTSpec.Children}}
					"{{.}}",
{{end}}
				},{{end}}
				{{if .UASTSpec.Props}}Props: map[string]string{
{{range $key, $value := .UASTSpec.Props}}
					"{{$key}}": "{{$value}}",
{{end}}
				},{{end}}
			},
			{{if .Conditions}}Conditions: []mapping.Condition{
{{range .Conditions}}
				{
					Expr: "{{.Expr}}",
				},
{{end}}
			},{{end}}
		},
{{end}}
	}

	patterns := make(map[string]mapping.Rule)
	ruleIndex := make(map[string]int)

	for i, rule := range rules {
		patterns[rule.Name] = rule
		ruleIndex[rule.Name] = i
	}

	return &{{.Language}}PatternMatcher{
		patterns: patterns,
		ruleIndex: ruleIndex,
		rules: rules,
	}
}

func (m *{{.Language}}PatternMatcher) MatchPattern(patternName string) (mapping.Rule, bool) {
	rule, exists := m.patterns[patternName]
	return rule, exists
}

func (m *{{.Language}}PatternMatcher) GetRuleByIndex(index int) (mapping.Rule, bool) {
	if index < 0 || index >= len(m.rules) {
		return mapping.Rule{}, false
	}
	return m.rules[index], true
}

func (m *{{.Language}}PatternMatcher) GetRuleIndex(patternName string) (int, bool) {
	index, exists := m.ruleIndex[patternName]
	return index, exists
}

func (m *{{.Language}}PatternMatcher) GetAllPatterns() map[string]mapping.Rule {
	return m.patterns
}

func (m *{{.Language}}PatternMatcher) GetRulesCount() int {
	return len(m.rules)
}
{{end}}

// OPTIMIZATION 2: Fast pattern matcher registry
var patternMatchers = map[string]interface{}{
{{range .}}
	"{{.Language}}": new{{.Language}}PatternMatcher(),
{{end}}
}

// GetPatternMatcher returns a pre-compiled pattern matcher for the given language
func GetPatternMatcher(language string) interface{} {
	return patternMatchers[language]
}

// OPTIMIZATION 3: Compile-time validation functions
{{range .}}
func validate{{.Language}}Rules() error {
	matcher := new{{.Language}}PatternMatcher()

	// Validate rule inheritance
	for _, rule := range matcher.rules {
		if rule.Extends != "" {
			if _, exists := matcher.patterns[rule.Extends]; !exists {
				return fmt.Errorf("{{.Language}}: rule '%s' extends non-existent rule '%s'", rule.Name, rule.Extends)
			}
		}

		// Validate UAST spec
		if rule.UASTSpec.Type == "" {
			return fmt.Errorf("{{.Language}}: rule '%s' has empty UAST type", rule.Name)
		}
	}

	return nil
}
{{end}}

// OPTIMIZATION 4: Performance metrics
var patternMatchMetrics = struct {
	matches map[string]int64
	misses  map[string]int64
}{
	matches: make(map[string]int64),
	misses:  make(map[string]int64),
}

func RecordPatternMatch(language, pattern string, matched bool) {
	key := language + ":" + pattern
	if matched {
		patternMatchMetrics.matches[key]++
	} else {
		patternMatchMetrics.misses[key]++
	}
}

func GetPatternMatchStats() map[string]int64 {
	stats := make(map[string]int64)
	for k, v := range patternMatchMetrics.matches {
		stats[k+"_matches"] = v
	}
	for k, v := range patternMatchMetrics.misses {
		stats[k+"_misses"] = v
	}
	return stats
}
`

	tmpl, tmplErr := template.New("go").Parse(goTemplate)
	if tmplErr != nil {
		panic(fmt.Sprintf("failed to parse template: %v", tmplErr))
	}

	var buf strings.Builder

	execErr := tmpl.Execute(&buf, mappings)
	if execErr != nil {
		panic(fmt.Sprintf("failed to execute template: %v", execErr))
	}

	return buf.String()
}
